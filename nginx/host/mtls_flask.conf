# Host Nginx config for mTLS in front of local Flask app
# Copy to /etc/nginx/sites-available/mtls_flask and enable via symlink to sites-enabled
# Adjust absolute paths to match your repo location on the host.

map $ssl_client_verify $client_verified {
    default $ssl_client_verify;
    "SUCCESS" "SUCCESS";
    "NONE" "NONE";
    "FAILED" "FAILED";
    "NO_CERT" "NO_CERT";
}

upstream flask_app_upstream {
    server 127.0.0.1:8000;
    keepalive 10;
}

server {
    listen 443 ssl http2;
    server_name _;  # adjust to your hostname if you have one

    # Server TLS cert/key (adjust to your paths)
    ssl_certificate     /flaskapp/rovo1/scripts/ca/out/server/localhost/server.crt;
    ssl_certificate_key /flaskapp/rovo1/scripts/ca/out/server/localhost/server.key;

    # Client auth trust store and CRL (REQUIRED for client cert prompt)
    # Make sure these paths point to your CA that issued the client certs.
    ssl_client_certificate /flaskapp/rovo1/scripts/ca/ca/certs/ca.crt;
    ssl_crl               /flaskapp/rovo1/scripts/ca/ca/crl/ca.crl;

    # IMPORTANT: keep this at the server {} level so the certificate is requested during initial handshake
    # Use `optional` if you want to allow users without a cert (X-Client-Verify will be NONE)
    ssl_verify_client optional;

    # Reasonable TLS settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;
    ssl_session_tickets off;

    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy strict-origin-when-cross-origin;
    # Content Security Policy: disallow inline by default; allow data: for images (QR)
    add_header Content-Security-Policy "default-src 'self'; img-src 'self' data:; script-src 'self'; style-src 'self'";

    # Health
    location /healthz {
        proxy_pass http://flask_app_upstream/healthz;
    }

    # Debug identity (shows cert headers)
    location /debug/identity {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Sanitized client cert metadata forwarded to app
        proxy_set_header X-Client-Verify $client_verified;
        proxy_set_header X-Client-Cert-Fingerprint $ssl_client_fingerprint;
        proxy_set_header X-Client-Cert-Serial $ssl_client_serial;
        proxy_set_header X-Client-Cert-Subject $ssl_client_s_dn;
        proxy_set_header X-Client-Cert-Issuer $ssl_client_i_dn;
        proxy_set_header X-Client-Cert $ssl_client_escaped_cert;

        proxy_pass http://flask_app_upstream/debug/identity;
    }

    # App
    location / {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        proxy_set_header X-Client-Verify $client_verified;
        proxy_set_header X-Client-Cert-Fingerprint $ssl_client_fingerprint;
        proxy_set_header X-Client-Cert-Serial $ssl_client_serial;
        proxy_set_header X-Client-Cert-Subject $ssl_client_s_dn;
        proxy_set_header X-Client-Cert-Issuer $ssl_client_i_dn;
        proxy_set_header X-Client-Cert $ssl_client_escaped_cert;

        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_pass http://flask_app_upstream;
    }
}
